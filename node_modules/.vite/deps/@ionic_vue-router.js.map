{
  "version": 3,
  "sources": ["../../@ionic/vue-router/dist-transpiled/locationHistory.js", "../../@ionic/vue-router/dist-transpiled/utils.js", "../../@ionic/vue-router/dist-transpiled/router.js", "../../@ionic/vue-router/dist-transpiled/viewStacks.js", "../../@ionic/vue-router/dist-transpiled/index.js"],
  "sourcesContent": ["export const createLocationHistory = () => {\n    const locationHistory = [];\n    const tabsHistory = {};\n    const add = (routeInfo) => {\n        switch (routeInfo.routerAction) {\n            case \"pop\":\n                pop(routeInfo);\n                break;\n            default:\n                addRoute(routeInfo);\n                break;\n        }\n        if (routeInfo.routerDirection === \"root\") {\n            clearHistory();\n            addRoute(routeInfo);\n        }\n    };\n    const update = (routeInfo) => {\n        const locationIndex = locationHistory.findIndex((x) => x.id === routeInfo.id);\n        if (locationIndex > -1) {\n            locationHistory.splice(locationIndex, 1, routeInfo);\n        }\n        const tabArray = tabsHistory[routeInfo.tab || \"\"];\n        if (tabArray) {\n            const tabIndex = tabArray.findIndex((x) => x.id === routeInfo.id);\n            if (tabIndex > -1) {\n                tabArray.splice(tabIndex, 1, routeInfo);\n            }\n            else {\n                tabArray.push(routeInfo);\n            }\n        }\n        else if (routeInfo.tab) {\n            tabsHistory[routeInfo.tab] = [routeInfo];\n        }\n    };\n    const pop = (routeInfo) => {\n        const tabHistory = getTabsHistory(routeInfo.tab);\n        let ri;\n        if (tabHistory) {\n            // Pop all routes until we are back\n            ri = tabHistory[tabHistory.length - 1];\n            while (ri && ri.id !== routeInfo.id) {\n                tabHistory.pop();\n                ri = tabHistory[tabHistory.length - 1];\n            }\n            // Replace with updated route\n            tabHistory.pop();\n            tabHistory.push(routeInfo);\n        }\n        ri = locationHistory[locationHistory.length - 1];\n        while (ri && ri.id !== routeInfo.id) {\n            locationHistory.pop();\n            ri = locationHistory[locationHistory.length - 1];\n        }\n        // Replace with updated route\n        locationHistory.pop();\n        locationHistory.push(routeInfo);\n    };\n    const addRoute = (routeInfo) => {\n        const tabHistory = getTabsHistory(routeInfo.tab);\n        if (tabHistory) {\n            // If the latest routeInfo is the same (going back and forth between tabs), replace it\n            if (tabHistory[tabHistory.length - 1] &&\n                tabHistory[tabHistory.length - 1].id === routeInfo.id) {\n                tabHistory.pop();\n            }\n            tabHistory.push(routeInfo);\n        }\n        locationHistory.push(routeInfo);\n    };\n    /**\n     * Wipes the location history arrays.\n     * You can optionally provide a routeInfo\n     * object which will wipe that entry\n     * and every entry that appears after it.\n     */\n    const clearHistory = (routeInfo) => {\n        if (routeInfo) {\n            const { position, tab } = routeInfo;\n            /**\n             * If there is no route index in locationHistory\n             * then there will not be any route index in\n             * tabs either.\n             */\n            const existingRouteIndex = locationHistory.findIndex((r) => r.position === position);\n            if (existingRouteIndex === -1)\n                return;\n            locationHistory.splice(existingRouteIndex);\n            const clearTabHistory = (tab) => {\n                const existingTabRouteIndex = tabsHistory[tab].findIndex((r) => r.position === position);\n                if (existingTabRouteIndex === -1)\n                    return;\n                tabsHistory[tab].splice(existingTabRouteIndex);\n            };\n            /**\n             * We also need to search the current tab\n             * to correctly reset the individual tab\n             * stack. We should not clear the entire\n             * tab stack as that means we will lose\n             * a reference to the root tab route.\n             */\n            const tabHistory = tabsHistory[tab];\n            if (tab && tabHistory) {\n                clearTabHistory(tab);\n                /**\n                 * If we are not clearing items after\n                 * a tabs page, it is still possible\n                 * that there are future tabs pages to clear.\n                 * As a result, we need to search through\n                 * all the tab stacks and remove views that appear\n                 * after the given routeInfo.\n                 *\n                 * Example: /non-tabs-page --> /tabs/tab1 --> /non-tabs-page\n                 * (via router.go(-1)) --> /tabs/tab2. The /tabs/tab1 history\n                 * has been overwritten with /tabs/tab2. As a result,\n                 * the /tabs/tab1 route info in the Tab 1 stack should be removed.\n                 */\n            }\n            else {\n                for (const tab in tabsHistory) {\n                    clearTabHistory(tab);\n                }\n            }\n        }\n        else {\n            for (const tab in tabsHistory) {\n                tabsHistory[tab] = [];\n            }\n            locationHistory.length = 0;\n        }\n    };\n    const getTabsHistory = (tab) => {\n        let history;\n        if (tab) {\n            history = tabsHistory[tab];\n            if (!history) {\n                history = tabsHistory[tab] = [];\n            }\n        }\n        return history;\n    };\n    const size = () => locationHistory.length;\n    /**\n     * Finds and returns the location history item\n     * given the state of browser's history API.\n     * This is useful when jumping around in browser\n     * history using router.go.\n     */\n    const current = (initialHistory, currentHistory) => {\n        /**\n         * initialHistory does not always start at 0 if users navigated\n         * to app from another website, so doing this math lets us\n         * find the correct index in our locationHistory array.\n         */\n        const index = currentHistory - initialHistory;\n        return locationHistory[index] || last();\n    };\n    const last = () => locationHistory[locationHistory.length - 1];\n    /**\n     * With the introduction of router.go support, we no longer remove\n     * items from locationHistory as they may be needed again in the future.\n     * As a result, we need to look at the current position in location history\n     * to see if users can navigate back n pages. Previously we were checking\n     * the length of locationHistory, but that only worked since we were pruning\n     * the array.\n     */\n    const canGoBack = (deep = 1, initialHistory, currentHistory) => {\n        return currentHistory - deep >= initialHistory;\n    };\n    const getFirstRouteInfoForTab = (tab) => {\n        const tabHistory = getTabsHistory(tab);\n        if (tabHistory) {\n            return tabHistory[0];\n        }\n        return undefined;\n    };\n    const getCurrentRouteInfoForTab = (tab) => {\n        const tabHistory = getTabsHistory(tab);\n        if (tabHistory) {\n            return tabHistory[tabHistory.length - 1];\n        }\n        return undefined;\n    };\n    /**\n     * Finds and returns the previous view based upon\n     * what originally pushed it (pushedByRoute).\n     * When `delta` < -1 then we should just index into\n     * to array because the previous view that we want is not\n     * necessarily the view that pushed our current view.\n     * Additionally, when jumping around in history, we\n     * do not modify the locationHistory stack so we would\n     * not update pushedByRoute anyways.\n     */\n    const findLastLocation = (routeInfo, delta = -1) => {\n        const routeInfos = getTabsHistory(routeInfo.tab);\n        if (routeInfos) {\n            if (delta < -1) {\n                return routeInfos[routeInfos.length - 1 + delta];\n            }\n            else {\n                for (let i = routeInfos.length - 2; i >= 0; i--) {\n                    const ri = routeInfos[i];\n                    if (ri) {\n                        if (ri.pathname === routeInfo.pushedByRoute) {\n                            return ri;\n                        }\n                    }\n                }\n            }\n        }\n        if (delta < -1) {\n            return locationHistory[locationHistory.length - 1 + delta];\n        }\n        else {\n            for (let i = locationHistory.length - 2; i >= 0; i--) {\n                const ri = locationHistory[i];\n                if (ri) {\n                    if (ri.pathname === routeInfo.pushedByRoute) {\n                        return ri;\n                    }\n                }\n            }\n        }\n        return undefined;\n    };\n    return {\n        current,\n        size,\n        last,\n        add,\n        canGoBack,\n        update,\n        getFirstRouteInfoForTab,\n        getCurrentRouteInfoForTab,\n        findLastLocation,\n        clearHistory,\n    };\n};\n//# sourceMappingURL=locationHistory.js.map", "const ids = { main: 0 };\nexport const generateId = (type = \"main\") => {\n    var _a;\n    const id = ((_a = ids[type]) !== null && _a !== void 0 ? _a : 0) + 1;\n    ids[type] = id;\n    return id.toString();\n};\n//# sourceMappingURL=utils.js.map", "import { parseQuery } from \"vue-router\";\nimport { createLocationHistory } from \"./locationHistory\";\nimport { generateId } from \"./utils\";\n// TODO(FW-2969): types\nexport const createIonRouter = (opts, router) => {\n    let currentNavigationInfo = {\n        direction: undefined,\n        action: undefined,\n        delta: undefined,\n    };\n    /**\n     * Ionic Vue should only react to navigation\n     * changes once they have been confirmed and should\n     * never affect the outcome of navigation (with the\n     * exception of going back or selecting a tab).\n     * As a result, we should do our work in afterEach\n     * which is fired once navigation is confirmed\n     * and any user guards have run.\n     */\n    router.afterEach((to, _, failure) => {\n        if (failure)\n            return;\n        const { direction, action, delta } = currentNavigationInfo;\n        /**\n         * When calling router.replace, we are not informed\n         * about the replace action in opts.history.listen\n         * but we can check to see if the latest routing action\n         * was a replace action by looking at the history state.\n         * We need to use opts.history rather than window.history\n         * because window.history will be undefined when using SSR.\n         */\n        currentHistoryPosition = opts.history.state.position;\n        const replaceAction = opts.history.state.replaced ? \"replace\" : undefined;\n        handleHistoryChange(to, action || replaceAction, direction, delta);\n        currentNavigationInfo = {\n            direction: undefined,\n            action: undefined,\n            delta: undefined,\n        };\n    });\n    const locationHistory = createLocationHistory();\n    /**\n     * Keeping track of the history position\n     * allows us to determine if a user is pushing\n     * new pages or updating history via the forward\n     * and back browser buttons.\n     */\n    let initialHistoryPosition = opts.history.state.position;\n    let currentHistoryPosition = opts.history.state.position;\n    let currentRouteInfo;\n    let incomingRouteParams;\n    const historyChangeListeners = [];\n    if (typeof document !== \"undefined\") {\n        document.addEventListener(\"ionBackButton\", (ev) => {\n            ev.detail.register(0, (processNextHandler) => {\n                opts.history.go(-1);\n                processNextHandler();\n            });\n        });\n    }\n    opts.history.listen((_, _x, info) => {\n        /**\n         * history.listen only fires on certain\n         * event such as when the user clicks the\n         * browser back button. It also gives us\n         * additional information as to the type\n         * of navigation (forward, backward, etc).\n         *\n         * We can use this to better handle the\n         * `handleHistoryChange` call in\n         * router.beforeEach\n         */\n        currentNavigationInfo = {\n            delta: info.delta,\n            /**\n             * Both the browser forward and backward actions\n             * are considered \"pop\" actions, but when going forward\n             * we want to make sure the forward animation is used.\n             */\n            action: info.type === \"pop\" && info.delta >= 1 ? \"push\" : info.type,\n            direction: info.direction === \"\" ? \"forward\" : info.direction,\n        };\n    });\n    const handleNavigateBack = (defaultHref, routerAnimation) => {\n        const routeInfo = locationHistory.current(initialHistoryPosition, currentHistoryPosition);\n        if (routeInfo && routeInfo.pushedByRoute) {\n            const prevInfo = locationHistory.findLastLocation(routeInfo);\n            if (prevInfo) {\n                incomingRouteParams = Object.assign(Object.assign({}, prevInfo), { routerAction: \"pop\", routerDirection: \"back\", routerAnimation: routerAnimation || routeInfo.routerAnimation });\n                if (routeInfo.lastPathname === routeInfo.pushedByRoute ||\n                    /**\n                     * We need to exclude tab switches/tab\n                     * context changes here because tabbed\n                     * navigation is not linear, but router.back()\n                     * will go back in a linear fashion.\n                     */\n                    (prevInfo.pathname === routeInfo.pushedByRoute &&\n                        /**\n                         * Tab info can be undefined or '' (empty string)\n                         * both are false-y values, so we can just use !.\n                         */\n                        !routeInfo.tab &&\n                        !prevInfo.tab)) {\n                    router.back();\n                }\n                else {\n                    /**\n                     * When going back to a child page of a tab\n                     * after being on another tab, we need to use\n                     * router.go() here instead of pushing or replacing.\n                     * Consider the following example:\n                     * /tabs/tab1 --> /tabs/tab1/child1 --> /tabs/tab1/child2\n                     * --> /tabs/tab2 (via Tab 2 button) --> /tabs/tab1/child2 (via Tab 1 button)\n                     *\n                     * Pressing the ion-back-button on /tabs/tab1/child2 should take\n                     * us back to /tabs/tab1/child1 not /tabs/tab2 because each tab\n                     * is its own stack.\n                     *\n                     * If we called pressed the ion-back-button and this code called\n                     * router.replace, then the state of /tabs/tab1/child2 would\n                     * be replaced with /tabs/tab1/child1. However, this means that\n                     * there would be two /tabs/tab1/child1 entries in the location\n                     * history as the original /tabs/tab1/child1 entry is still there.\n                     * As a result, clicking the ion-back-button on /tabs/tab1/child1 does\n                     * nothing because this code would try to route to the same page\n                     * we are currently on.\n                     *\n                     * If we called router.push instead then we would push a\n                     * new /tabs/tab1/child1 entry to the location history. This\n                     * is not good because we would have two /tabs/tab1/child1 entries\n                     * separated by a /tabs/tab1/child2 entry.\n                     */\n                    router.go(prevInfo.position - routeInfo.position);\n                }\n            }\n            else {\n                handleNavigate(defaultHref, \"pop\", \"back\");\n            }\n        }\n        else {\n            handleNavigate(defaultHref, \"pop\", \"back\");\n        }\n    };\n    const handleNavigate = (path, routerAction, routerDirection, routerAnimation, tab) => {\n        setIncomingRouteParams(routerAction, routerDirection, routerAnimation, tab);\n        if (routerAction === \"push\") {\n            router.push(path);\n        }\n        else {\n            router.replace(path);\n        }\n    };\n    // TODO RouteLocationNormalized\n    const handleHistoryChange = (location, action, direction, delta) => {\n        let leavingLocationInfo;\n        if (incomingRouteParams) {\n            /**\n             * If we are replacing the state of a route\n             * with another route, the \"leaving\" route\n             * is at the same position in location history\n             * as where the replaced route will exist.\n             */\n            if (incomingRouteParams.routerAction === \"replace\") {\n                leavingLocationInfo = locationHistory.current(initialHistoryPosition, currentHistoryPosition);\n            }\n            else if (incomingRouteParams.routerAction === \"pop\") {\n                leavingLocationInfo = locationHistory.current(initialHistoryPosition, currentHistoryPosition + 1);\n                /**\n                 * If the Ionic Router action was \"pop\"\n                 * and the browser history action was \"replace\", then\n                 * it is the case that the user clicked an IonBackButton\n                 * that is trying to go back to the route specified\n                 * by the defaultHref property.\n                 *\n                 * The problem is that this route currently does\n                 * not exist in the browser history, and we cannot\n                 * prepend an item in the browser's history stack.\n                 * To work around this, we replace the state of\n                 * the current item instead.\n                 * Given this scenario:\n                 * /page2 --> /page3 --> (back) /page2 --> (defaultHref) /page1\n                 * We would replace the state of /page2 with the state of /page1.\n                 *\n                 * When doing this, we are essentially re-writing past\n                 * history which makes the future history no longer relevant.\n                 * As a result, we clear out the location history so that users\n                 * can begin pushing new routes to the stack.\n                 *\n                 * This pattern is aligned with how the browser handles\n                 * pushing new routes after going back as well as how\n                 * other stack based operations such as undo/redo work.\n                 * For example, if you do tasks A, B, C, undo B and C, and\n                 * then do task D, you cannot \"redo\" B and C because you\n                 * rewrote the stack's past history.\n                 *\n                 * With browser history, it is a similar concept.\n                 * Going /page1 --> /page2 --> /page3 and then doing\n                 * router.go(-2) will bring you back to /page1.\n                 * If you then push /page4, you have rewritten\n                 * the past history and you can no longer go\n                 * forward to /page2 or /page3.\n                 */\n                if (action === \"replace\") {\n                    locationHistory.clearHistory();\n                }\n            }\n            else {\n                /**\n                 * If the routerDirection was specified as \"root\", then\n                 * we are replacing the initial state of location history\n                 * with this incoming route. As a result, the leaving\n                 * history info is stored at the same location as\n                 * where the incoming history location will be stored.\n                 *\n                 * Otherwise, we can assume this is just another route\n                 * that will be pushed onto the end of location history,\n                 * so we can grab the previous item in history relative\n                 * to where the history state currently is.\n                 */\n                const position = incomingRouteParams.routerDirection === \"root\"\n                    ? currentHistoryPosition\n                    : currentHistoryPosition - 1;\n                leavingLocationInfo = locationHistory.current(initialHistoryPosition, position);\n            }\n        }\n        else {\n            leavingLocationInfo = currentRouteInfo;\n        }\n        if (!leavingLocationInfo) {\n            leavingLocationInfo = {\n                pathname: \"\",\n                search: \"\",\n            };\n        }\n        const leavingUrl = leavingLocationInfo.pathname + leavingLocationInfo.search;\n        if (leavingUrl !== location.fullPath) {\n            if (!incomingRouteParams) {\n                if (action === \"replace\") {\n                    incomingRouteParams = {\n                        routerAction: \"replace\",\n                        routerDirection: \"none\",\n                    };\n                }\n                else if (action === \"pop\") {\n                    const routeInfo = locationHistory.current(initialHistoryPosition, currentHistoryPosition - delta);\n                    if (routeInfo && routeInfo.pushedByRoute) {\n                        const prevRouteInfo = locationHistory.findLastLocation(routeInfo, delta);\n                        incomingRouteParams = Object.assign(Object.assign({}, prevRouteInfo), { routerAction: \"pop\", routerDirection: \"back\" });\n                    }\n                    else {\n                        incomingRouteParams = {\n                            routerAction: \"pop\",\n                            routerDirection: \"none\",\n                        };\n                    }\n                }\n                if (!incomingRouteParams) {\n                    incomingRouteParams = {\n                        routerAction: \"push\",\n                        routerDirection: direction || \"forward\",\n                    };\n                }\n            }\n            let routeInfo;\n            if (incomingRouteParams === null || incomingRouteParams === void 0 ? void 0 : incomingRouteParams.id) {\n                routeInfo = Object.assign(Object.assign({}, incomingRouteParams), { lastPathname: leavingLocationInfo.pathname });\n            }\n            else {\n                const isPushed = incomingRouteParams.routerAction === \"push\" &&\n                    incomingRouteParams.routerDirection === \"forward\";\n                routeInfo = Object.assign(Object.assign({ id: generateId(\"routeInfo\") }, incomingRouteParams), { lastPathname: leavingLocationInfo.pathname, pathname: location.path, search: (location.fullPath && location.fullPath.split(\"?\")[1]) || \"\", params: location.params && location.params, prevRouteLastPathname: leavingLocationInfo.lastPathname });\n                if (isPushed) {\n                    routeInfo.pushedByRoute =\n                        leavingLocationInfo.pathname !== \"\"\n                            ? leavingLocationInfo.pathname\n                            : undefined;\n                }\n                else if (routeInfo.routerAction === \"pop\") {\n                    const route = locationHistory.findLastLocation(routeInfo);\n                    routeInfo.pushedByRoute = route === null || route === void 0 ? void 0 : route.pushedByRoute;\n                }\n                else if (routeInfo.routerAction === \"push\" &&\n                    routeInfo.tab !== leavingLocationInfo.tab) {\n                    const lastRoute = locationHistory.getCurrentRouteInfoForTab(routeInfo.tab);\n                    routeInfo.pushedByRoute = lastRoute === null || lastRoute === void 0 ? void 0 : lastRoute.pushedByRoute;\n                }\n                else if (routeInfo.routerAction === \"replace\") {\n                    /**\n                     * When replacing a route, we want to make sure we select the current route\n                     * that we are on, not the last route in the stack. The last route in the stack\n                     * is not always the current route.\n                     * Example:\n                     * Given the following history: /page1 --> /page2\n                     * Doing router.go(-1) would bring you to /page1.\n                     * If you then did router.replace('/page3'), /page1 should\n                     * be replaced with /page3 even though /page2 is the last\n                     * item in the stack/\n                     */\n                    const currentRouteInfo = locationHistory.current(initialHistoryPosition, currentHistoryPosition);\n                    /**\n                     * If going from /home to /child, then replacing from\n                     * /child to /home, we don't want the route info to\n                     * say that /home was pushed by /home which is not correct.\n                     */\n                    const currentPushedBy = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pushedByRoute;\n                    const pushedByRoute = currentPushedBy !== undefined &&\n                        currentPushedBy !== routeInfo.pathname\n                        ? currentPushedBy\n                        : routeInfo.pushedByRoute;\n                    routeInfo.lastPathname =\n                        (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.pathname) || routeInfo.lastPathname;\n                    routeInfo.pushedByRoute = pushedByRoute;\n                    routeInfo.routerDirection =\n                        (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routerDirection) || routeInfo.routerDirection;\n                    routeInfo.routerAnimation =\n                        (currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.routerAnimation) || routeInfo.routerAnimation;\n                    routeInfo.prevRouteLastPathname = currentRouteInfo === null || currentRouteInfo === void 0 ? void 0 : currentRouteInfo.lastPathname;\n                }\n            }\n            routeInfo.position = currentHistoryPosition;\n            routeInfo.delta = delta;\n            const historySize = locationHistory.size();\n            const historyDiff = currentHistoryPosition - initialHistoryPosition;\n            /**\n             * If the size of location history is greater\n             * than the difference between the current history\n             * position and the initial history position\n             * then we are guaranteed to already have a history\n             * item for this route. In other words, a user\n             * is navigating within the history without pushing\n             * new items within the stack.\n             *\n             * If the historySize === historyDiff,\n             * then we are still re-writing history\n             * by replacing the current route state\n             * with a new route state. The initial\n             * action when loading an app is\n             * going to be replace operation, so\n             * we want to make sure we exclude that\n             * action by ensuring historySize > 0.\n             */\n            const isReplacing = historySize === historyDiff && historySize > 0 && action === \"replace\";\n            if (historySize > historyDiff || isReplacing) {\n                /**\n                 * When navigating back through the history,\n                 * if users then push a new route the future\n                 * history stack is no longer relevant. As\n                 * a result, we need to clear out all entries\n                 * that appear after the current routeInfo\n                 * so that we can then append the new history.\n                 *\n                 * This does not apply when using router.go\n                 * as that is traversing through the history,\n                 * not altering it.\n                 *\n                 * Previously we had only updated the existing route\n                 * and then left the future history alone. That\n                 * worked for some use cases but was not sufficient\n                 * in other scenarios.\n                 */\n                if ((routeInfo.routerAction === \"push\" ||\n                    routeInfo.routerAction === \"replace\") &&\n                    delta === undefined) {\n                    locationHistory.clearHistory(routeInfo);\n                    locationHistory.add(routeInfo);\n                }\n            }\n            else {\n                locationHistory.add(routeInfo);\n            }\n            /**\n             * If we recently reset the location history\n             * then we also need to update the initial\n             * history position.\n             */\n            if (locationHistory.size() === 1) {\n                initialHistoryPosition = routeInfo.position;\n            }\n            currentRouteInfo = routeInfo;\n        }\n        incomingRouteParams = undefined;\n        historyChangeListeners.forEach((cb) => cb(currentRouteInfo));\n    };\n    const getCurrentRouteInfo = () => currentRouteInfo;\n    const canGoBack = (deep = 1) => locationHistory.canGoBack(deep, initialHistoryPosition, currentHistoryPosition);\n    const navigate = (navigationOptions) => {\n        const { routerAnimation, routerDirection, routerLink } = navigationOptions;\n        setIncomingRouteParams(\"push\", routerDirection, routerAnimation);\n        router.push(routerLink);\n    };\n    const resetTab = (tab) => {\n        /**\n         * Resetting the tab should go back\n         * to the initial view in the tab stack.\n         * It should not push a new instance of the\n         * root tab page onto the stack.\n         *\n         * To do this, we get the initial view in the\n         * tab stack and subtract the position of that\n         * entry from our current position. From there\n         * we call router.go() to move us back the\n         * appropriate number of positions.\n         */\n        const routeInfo = locationHistory.getFirstRouteInfoForTab(tab);\n        if (routeInfo) {\n            router.go(routeInfo.position - currentHistoryPosition);\n        }\n    };\n    const changeTab = (tab, path) => {\n        if (!path)\n            return;\n        const routeInfo = locationHistory.getCurrentRouteInfoForTab(tab);\n        const [pathname] = path.split(\"?\");\n        if (routeInfo) {\n            incomingRouteParams = Object.assign(Object.assign({}, incomingRouteParams), { routerAction: \"push\", routerDirection: \"none\", tab });\n            /**\n             * When going back to a tab\n             * you just left, it's possible\n             * for the route info to be incorrect\n             * as the tab you want is not the\n             * tab you are on.\n             */\n            if (routeInfo.pathname === pathname) {\n                router.push({\n                    path: routeInfo.pathname,\n                    query: parseQuery(routeInfo.search),\n                });\n            }\n            else {\n                router.push({ path: pathname, query: parseQuery(routeInfo.search) });\n            }\n        }\n        else {\n            handleNavigate(pathname, \"push\", \"none\", undefined, tab);\n        }\n    };\n    /**\n     * This method is invoked by the IonTabs component\n     * during a history change callback. It is responsible\n     * for ensuring that tabbed routes have the correct\n     * \"tab\" field in its routeInfo object.\n     *\n     * IonTabs will determine if the current route\n     * is in tabs and assign it the correct tab.\n     * If the current route is not in tabs,\n     * then IonTabs will not invoke this.\n     */\n    const handleSetCurrentTab = (tab) => {\n        /**\n         * Note that the current page that we\n         * are on is not necessarily the last item\n         * in the locationHistory stack. As a result,\n         * we cannot use locationHistory.last() here.\n         */\n        const ri = Object.assign({}, locationHistory.current(initialHistoryPosition, currentHistoryPosition));\n        /**\n         * handleHistoryChange is tabs-agnostic by design.\n         * One side effect of this is that certain tabs\n         * routes have extraneous/incorrect information\n         * that we need to remove. To not tightly couple\n         * handleHistoryChange with tabs, we let the\n         * handleSetCurrentTab function. This function is\n         * only called by IonTabs.\n         */\n        if (ri.tab !== tab) {\n            ri.tab = tab;\n            locationHistory.update(ri);\n        }\n        /**\n         * lastPathname typically equals pushedByRoute\n         * when navigating in a linear manner. When switching between\n         * tabs, this is almost never the case.\n         *\n         * Example: /tabs/tabs1 --> /tabs/tab2 --> /tabs/tab1\n         * The latest Tab 1 route would have the following information\n         * lastPathname: '/tabs/tab2'\n         * pushedByRoute: '/tabs/tab2'\n         *\n         * A tab cannot push another tab, so we need to set\n         * pushedByRoute to `undefined`. Alternative way of thinking\n         * about this: You cannot swipe to go back from Tab 1 to Tab 2.\n         *\n         * However, there are some instances where we do want to keep\n         * the pushedByRoute. As a result, we need to ensure that\n         * we only wipe the pushedByRoute state when the both of the\n         * following conditions are met:\n         * 1. pushedByRoute is different from lastPathname\n         * 2. The tab for the pushedByRoute info is different\n         * from the current route tab.\n         *\n         * Example of when we would not want to clear pushedByRoute:\n         * /tabs/tab1 --> /tabs/tab1/child --> /tabs/tab2 --> /tabs/tab1/child\n         * The latest Tab 1 Child route would have the following information:\n         * lastPathname: '/tabs/tab2'\n         * pushedByRoute: '/tabs/tab1\n         *\n         * In this case, /tabs/tab1/child should be able to swipe to go back\n         * to /tabs/tab1 so we want to keep the pushedByRoute.\n         */\n        const pushedByRoute = locationHistory.findLastLocation(ri);\n        if (ri.pushedByRoute !== ri.lastPathname && (pushedByRoute === null || pushedByRoute === void 0 ? void 0 : pushedByRoute.tab) !== tab) {\n            ri.pushedByRoute = undefined;\n            locationHistory.update(ri);\n        }\n    };\n    const registerHistoryChangeListener = (cb) => {\n        historyChangeListeners.push(cb);\n    };\n    const setIncomingRouteParams = (routerAction = \"push\", routerDirection = \"forward\", routerAnimation, tab) => {\n        incomingRouteParams = {\n            routerAction,\n            routerDirection,\n            routerAnimation,\n            tab,\n        };\n    };\n    const goBack = (routerAnimation) => {\n        setIncomingRouteParams(\"pop\", \"back\", routerAnimation);\n        router.back();\n    };\n    const goForward = (routerAnimation) => {\n        setIncomingRouteParams(\"push\", \"forward\", routerAnimation);\n        router.forward();\n    };\n    const getLeavingRouteInfo = () => {\n        return locationHistory.current(initialHistoryPosition, currentHistoryPosition);\n    };\n    return {\n        handleNavigate,\n        getLeavingRouteInfo,\n        handleNavigateBack,\n        handleSetCurrentTab,\n        getCurrentRouteInfo,\n        canGoBack,\n        navigate,\n        resetTab,\n        changeTab,\n        registerHistoryChangeListener,\n        goBack,\n        goForward,\n    };\n};\n//# sourceMappingURL=router.js.map", "import { shallowRef } from \"vue\";\nimport { generateId } from \"./utils\";\nexport const createViewStacks = (router) => {\n    const viewStacks = {};\n    /**\n     * Returns the number of active stacks.\n     * This is useful for determining if an app\n     * is using linear navigation only or non-linear\n     * navigation. Multiple stacks indiciate an app\n     * is using non-linear navigation.\n     */\n    const size = () => Object.keys(viewStacks).length;\n    const clear = (outletId) => {\n        delete viewStacks[outletId];\n    };\n    const getViewStack = (outletId) => {\n        return viewStacks[outletId];\n    };\n    const registerIonPage = (viewItem, ionPage) => {\n        viewItem.ionPageElement = ionPage;\n        viewItem.ionRoute = true;\n        /**\n         * This is needed otherwise Vue Router\n         * will not consider this component mounted\n         * and will not run route guards that\n         * are written in the component.\n         */\n        viewItem.matchedRoute.instances = {\n            default: viewItem.vueComponentRef.value,\n        };\n    };\n    const findViewItemByRouteInfo = (routeInfo, outletId) => {\n        return findViewItemByPath(routeInfo.pathname, outletId, false);\n    };\n    const findLeavingViewItemByRouteInfo = (routeInfo, outletId, mustBeIonRoute = true) => {\n        return findViewItemByPath(routeInfo.lastPathname, outletId, mustBeIonRoute);\n    };\n    const findViewItemByPathname = (pathname, outletId) => {\n        return findViewItemByPath(pathname, outletId, false);\n    };\n    const findViewItemInStack = (path, stack) => {\n        return stack.find((viewItem) => {\n            if (viewItem.pathname === path) {\n                return viewItem;\n            }\n            return undefined;\n        });\n    };\n    const findViewItemByPath = (path, outletId, mustBeIonRoute = false) => {\n        const matchView = (viewItem) => {\n            if ((mustBeIonRoute && !viewItem.ionRoute) || path === \"\") {\n                return false;\n            }\n            const resolvedPath = router.resolve(path);\n            const findMatchedRoute = resolvedPath.matched.find((matchedRoute) => matchedRoute === viewItem.matchedRoute);\n            if (findMatchedRoute) {\n                /**\n                 * /page/1 and /page/2 should not match\n                 * to the same view item otherwise there will\n                 * be not page transition and we will need to\n                 * explicitly clear out parameters from page 1\n                 * so the page 2 params are properly passed\n                 * to the developer's app.\n                 */\n                const hasParameter = findMatchedRoute.path.includes(\":\");\n                if (hasParameter && path !== viewItem.pathname) {\n                    return false;\n                }\n                return viewItem;\n            }\n            return undefined;\n        };\n        if (outletId) {\n            const stack = viewStacks[outletId];\n            if (!stack)\n                return undefined;\n            const match = router\n                ? stack.find(matchView)\n                : findViewItemInStack(path, stack);\n            if (match)\n                return match;\n        }\n        else {\n            for (const outletId in viewStacks) {\n                const stack = viewStacks[outletId];\n                const viewItem = findViewItemInStack(path, stack);\n                if (viewItem) {\n                    return viewItem;\n                }\n            }\n        }\n        return undefined;\n    };\n    // TODO(FW-2969): type\n    const createViewItem = (outletId, vueComponent, matchedRoute, routeInfo, ionPage) => {\n        return {\n            id: generateId(\"viewItem\"),\n            pathname: routeInfo.pathname,\n            outletId,\n            matchedRoute,\n            ionPageElement: ionPage,\n            vueComponent,\n            vueComponentRef: shallowRef(),\n            ionRoute: false,\n            mount: false,\n            exact: routeInfo.pathname === matchedRoute.path,\n            params: routeInfo.params,\n            vueComponentData: {},\n        };\n    };\n    const add = (viewItem) => {\n        const { outletId } = viewItem;\n        if (!viewStacks[outletId]) {\n            viewStacks[outletId] = [viewItem];\n        }\n        else {\n            viewStacks[outletId].push(viewItem);\n        }\n    };\n    const remove = (viewItem, outletId) => {\n        if (!outletId) {\n            throw Error(\"outletId required\");\n        }\n        const viewStack = viewStacks[outletId];\n        if (viewStack) {\n            viewStacks[outletId] = viewStack.filter((item) => item.id !== viewItem.id);\n        }\n    };\n    const getChildrenToRender = (outletId) => {\n        const viewStack = viewStacks[outletId];\n        if (viewStack) {\n            const components = viewStacks[outletId].filter((v) => v.mount);\n            return components;\n        }\n        return [];\n    };\n    /**\n     * When navigating backwards, we need to clean up and\n     * leaving pages so that they are re-created if\n     * we ever navigate back to them. This is especially\n     * important when using router.go and stepping back\n     * multiple pages at a time.\n     */\n    const unmountLeavingViews = (outletId, viewItem, delta = 1) => {\n        const viewStack = viewStacks[outletId];\n        if (!viewStack)\n            return;\n        const startIndex = viewStack.findIndex((v) => v === viewItem);\n        for (let i = startIndex + 1; i < startIndex - delta; i++) {\n            const viewItem = viewStack[i];\n            viewItem.mount = false;\n            viewItem.ionPageElement = undefined;\n            viewItem.ionRoute = false;\n            viewItem.matchedRoute.instances = {};\n        }\n    };\n    /**\n     * When navigating forward it is possible for\n     * developers to step forward over multiple views.\n     * The intermediary views need to be remounted so that\n     * swipe to go back works properly.\n     * We need to account for the delta value here too because\n     * we do not want to remount an unrelated view.\n     * Example:\n     * /home --> /page2 --> router.back() --> /page3\n     * Going to /page3 would remount /page2 since we do\n     * not prune /page2 from the stack. However, /page2\n     * needs to remain in the stack.\n     * Example:\n     * /home --> /page2 --> /page3 --> router.go(-2) --> router.go(2)\n     * We would end up on /page3, but users need to be able to swipe\n     * to go back to /page2 and /home, so we need both pages mounted\n     * in the DOM.\n     */\n    const mountIntermediaryViews = (outletId, viewItem, delta = 1) => {\n        const viewStack = viewStacks[outletId];\n        if (!viewStack)\n            return;\n        const startIndex = viewStack.findIndex((v) => v === viewItem);\n        for (let i = startIndex + 1; i < startIndex + delta; i++) {\n            viewStack[i].mount = true;\n        }\n    };\n    return {\n        unmountLeavingViews,\n        mountIntermediaryViews,\n        clear,\n        findViewItemByRouteInfo,\n        findLeavingViewItemByRouteInfo,\n        findViewItemByPathname,\n        createViewItem,\n        getChildrenToRender,\n        add,\n        remove,\n        registerIonPage,\n        getViewStack,\n        size,\n    };\n};\n//# sourceMappingURL=viewStacks.js.map", "import { createRouter as createVueRouter, createWebHistory as createVueWebHistory, createWebHashHistory as createVueWebHashHistory, createMemoryHistory as createVueMemoryHistory, } from \"vue-router\";\nimport { createIonRouter } from \"./router\";\nimport { createViewStacks } from \"./viewStacks\";\nexport const createRouter = (opts) => {\n    const routerOptions = Object.assign({}, opts);\n    delete routerOptions.tabsPrefix;\n    const router = createVueRouter(routerOptions);\n    const ionRouter = createIonRouter(opts, router);\n    const viewStacks = createViewStacks(router);\n    const oldInstall = router.install.bind(router);\n    router.install = (app) => {\n        app.provide(\"navManager\", ionRouter);\n        app.provide(\"viewStacks\", viewStacks);\n        oldInstall(app);\n    };\n    const oldIsReady = router.isReady.bind(router);\n    router.isReady = () => oldIsReady();\n    return router;\n};\nexport const createWebHistory = (base) => createVueWebHistory(base);\nexport const createWebHashHistory = (base) => createVueWebHashHistory(base);\nexport const createMemoryHistory = (base) => createVueMemoryHistory(base);\n//# sourceMappingURL=index.js.map"],
  "mappings": "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",
  "names": ["tab", "routeInfo", "currentRouteInfo", "outletId", "viewItem", "createRouter", "createVueRouter", "createWebHistory", "createVueWebHistory", "createWebHashHistory", "createVueWebHashHistory", "createMemoryHistory", "createVueMemoryHistory"]
}
